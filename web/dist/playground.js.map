{
  "version": 3,
  "sources": ["../src/barry.ts", "../src/console.ts", "../src/playground.ts"],
  "sourcesContent": ["// barry.ts\n// A simple parser for parsing expressions into an AST of ideas\n\n// Combined regex pattern for token matching with global flag\n// Order matters: quoted strings, wraps (parens), numbers, seals, unquoted strings, whitespace\nconst TOKEN_PATTERN =\n  /(?:\"(?<quoted>[^\"]*)\"|(?<open>\\()|(?<close>\\))|(?<number>-?\\d+\\.?\\d*)|(?<seal>[^\\w\\s\"()]+)|(?<string>\\S+)|(?<append>\\s+))/g\n\n// Helper function to display an idea - Lists without parentheses\nexport function LineView(idea: Idea): string {\n  if (idea instanceof List) {\n    return idea.LineView()\n  }\n  return idea.View()\n}\n\n// Test function\nexport function Test() {\n  console.log(\"=== Barry Parser Tests ===\")\n\n  const testCases = [\n    \"1234\",\n    \"  42.5  \",\n    \"-7\",\n    \"12 34\",\n    \"12 (34 56) 78\",\n    \"12+34\",\n    \"1+2+3\",\n  ]\n\n  const parser = new Parser()\n  for (const input of testCases) {\n    console.log(`\\nInput: \"${input}\"`)\n    try {\n      const result = parser.start(input)\n      console.log(`  Result: ${LineView(result)}`)\n    } catch (e) {\n      console.error(`  Error: ${e}`)\n    }\n  }\n\n  console.log(\"\\n=== Tests Complete ===\")\n}\n\n// Seal map - maps seal strings to their idea constructors\nconst SealMap = new Map<string, () => Idea>([[\"+\", () => new Add()]])\n\n// Name map - maps unquoted strings to their idea constructors\nconst NameMap = new Map<string, () => Idea>([])\n\n// Parser extracts tokens on-demand and creates ideas from input string\nexport class Parser {\n  private regex: RegExp\n  private input: string = \"\"\n  tokens: { endIndex: number; idea: Idea }[] = []\n\n  constructor() {\n    this.regex = new RegExp(TOKEN_PATTERN.source, TOKEN_PATTERN.flags)\n  }\n\n  // Parse a seal string and return the longest matching seal idea\n  // Resets regex index so remaining characters will be matched in next call\n  private parseSeal(sealString: string, matchEndPos: number): Idea {\n    // Try matching from longest to shortest\n    for (let len = sealString.length; len > 0; len--) {\n      const candidate = sealString.substring(0, len)\n      if (SealMap.has(candidate)) {\n        // Found a match, reset index to position after this seal\n        const consumedLength = len\n        this.regex.lastIndex = matchEndPos - sealString.length + consumedLength\n        return SealMap.get(candidate)!()\n      }\n    }\n\n    // No match found - return error idea\n    const errorIdea = new Err(`Unknown seal: ${sealString[0]}`)\n    this.tokens.push({\n      endIndex: matchEndPos,\n      idea: errorIdea,\n    })\n    return errorIdea\n  }\n\n  // Entry point for parsing - handles root list with special processing\n  start(input: string): Idea {\n    // Reset state for new input\n    this.input = input\n    this.regex.lastIndex = 0\n    this.tokens = []\n\n    // Create root list\n    const rootList = new List()\n\n    // Append loop: consume ideas until EOF\n    while (true) {\n      const idea = this.next(null, 0)\n      if (idea === null) {\n        break\n      }\n      rootList.append(idea)\n    }\n\n    // Post-processing: convert based on number of items\n    if (rootList.items.length === 0) {\n      // Empty list becomes Nothing\n      return new Nothing()\n    } else if (rootList.items.length === 1) {\n      // Single element: (x) = x\n      return rootList.items[0]\n    }\n    // Multiple elements: return the list\n    return rootList\n  }\n\n  // Get next idea from current position\n  // prev is the idea to the left (can be null)\n  // suitor is the precedence of the left suitor (0 = no suitor, e.g. in append loops)\n  // Returns null if EOF or no valid idea can be created\n  // In look-ahead mode (prev !== null), returns null if idea doesn't need prev as left argument\n  // Rewinds position if returning null\n  next(prev: Idea | null, suitor: number): Idea | null {\n    const savedPos = this.regex.lastIndex\n    const savedTokenCount = this.tokens.length\n    const rewind = () => {\n      this.regex.lastIndex = savedPos\n      this.tokens.length = savedTokenCount\n    }\n\n    let match = this.regex.exec(this.input)\n\n    while (match && match.groups?.append !== undefined) {\n      match = this.regex.exec(this.input)\n    }\n\n    if (!match || !match.groups) {\n      rewind()\n      return null\n    }\n\n    let idea: Idea | null = null\n\n    if (match.groups.number !== undefined) {\n      idea = new Num(match.groups.number)\n    } else if (match.groups.quoted !== undefined) {\n      // Create Str idea from quoted string (quotes already removed by regex)\n      idea = new Str(match.groups.quoted)\n    } else if (match.groups.open !== undefined) {\n      // Opening parenthesis - create List\n      idea = new List()\n    } else if (match.groups.close !== undefined) {\n      // Closing parenthesis - create Closure\n      idea = new Closure()\n    } else if (match.groups.string !== undefined) {\n      // Look up in NameMap, create Str if not found\n      if (NameMap.has(match.groups.string)) {\n        idea = NameMap.get(match.groups.string)!()\n      } else {\n        idea = new Str(match.groups.string)\n      }\n    } else if (match.groups.seal !== undefined) {\n      // Parse seal - may reset index for remaining characters\n      idea = this.parseSeal(match.groups.seal, this.regex.lastIndex)\n    } else {\n      rewind()\n      return null\n    }\n\n    // Add token info for successfully parsed idea (skip Closure - it's handled by List)\n    if (!(idea instanceof Closure)) {\n      this.tokens.push({\n        endIndex: this.regex.lastIndex,\n        idea: idea,\n      })\n    }\n\n    console.log(\"Created idea:\", idea instanceof Closure ? \")\" : idea.View())\n\n    // Look-ahead check: if prev is provided, try to consume it\n    if (prev !== null) {\n      // Check precedence: only consume if our precedence is >= suitor\n      if (idea.precedence < suitor) {\n        rewind()\n        return null\n      }\n      const consumed = idea.consumePre(prev)\n      if (consumed === null) {\n        // prev not consumed, return null\n        rewind()\n        return null\n      }\n      // prev consumed, use the returned idea\n      idea = consumed\n    }\n\n    // Handle Closure - return immediately after look-ahead check\n    if (idea instanceof Closure) {\n      return idea\n    }\n\n    // Handle List - run append loop until Closure or EOF\n    if (idea instanceof List) {\n      while (true) {\n        const item = this.next(null, 0)\n        if (item === null) {\n          // EOF - end of list\n          break\n        }\n        if (item instanceof Closure) {\n          // Add the same List idea again for the closing paren\n          this.tokens.push({\n            endIndex: this.regex.lastIndex,\n            idea: idea,\n          })\n          break\n        }\n        idea.append(item)\n      }\n\n      // Post-process: empty list becomes Nothing\n      if (idea.items.length === 0) {\n        idea = new Nothing()\n      }\n    }\n\n    // Fill recursion: if idea has right argument slots, try to fill them\n    if (\"consumePost\" in idea) {\n      const postPos = this.regex.lastIndex\n      const rewindPost = () => {\n        this.regex.lastIndex = postPos\n      }\n      const nextIdea = this.next(null, idea.precedence)\n      if (nextIdea !== null) {\n        if (!(idea as any).consumePost(nextIdea)) {\n          // Didn't consume, rewind so next idea can be used elsewhere\n          rewindPost()\n        }\n      }\n    }\n\n    // Look-ahead recursion: check if something needs this idea as left argument\n    // Pass the suitor precedence we received, not our own\n    const nextIdea = this.next(idea, suitor)\n    if (nextIdea !== null) {\n      return nextIdea\n    }\n\n    return idea\n  }\n}\n\n// Base class for all ideas (AST nodes)\nexport abstract class Idea {\n  precedence: number = 0\n  finished: boolean = false\n  complete: boolean = false // Ideas are incomplete by default\n\n  // Default: ideas don't consume pre (return null)\n  consumePre(prev: Idea): Idea | null {\n    return null\n  }\n\n  abstract View(): string\n  abstract Color(): string\n}\n\n// Err idea - represents a parse error\nexport class Err extends Idea {\n  message: string\n\n  constructor(message: string) {\n    super()\n    this.message = message\n    this.complete = true // Error doesn't need arguments\n  }\n\n  View(): string {\n    return `Error: ${this.message}`\n  }\n\n  Color(): string {\n    return \"#fc4b28\" // Red for errors\n  }\n}\n\n// Num idea - stores numeric values\nexport class Num extends Idea {\n  value: number\n\n  constructor(match: string) {\n    super()\n    this.value = parseFloat(match)\n    this.complete = true\n  }\n\n  View(): string {\n    return this.value.toString()\n  }\n\n  Color(): string {\n    return \"#a6da95\" // Green for numbers\n  }\n}\n\n// Str idea - stores string values\nexport class Str extends Idea {\n  value: string\n\n  constructor(match: string) {\n    super()\n    this.value = match\n    this.complete = true\n  }\n\n  View(): string {\n    return '\"' + this.value + '\"'\n  }\n\n  Color(): string {\n    return \"#eed49f\" // Yellow for strings\n  }\n}\n\n// List idea - contains sequence of ideas\nexport class List extends Idea {\n  items: Idea[] = []\n\n  constructor() {\n    super()\n    this.complete = true\n  }\n\n  append(idea: Idea) {\n    this.items.push(idea)\n  }\n\n  View(): string {\n    return \"(\" + this.items.map((item) => item.View()).join(\" \") + \")\"\n  }\n\n  LineView(): string {\n    return this.items.map((item) => item.View()).join(\" \")\n  }\n\n  Color(): string {\n    return \"#5da4f4\" // Blue for lists/parens\n  }\n}\n\n// Nothing idea - empty expression\nexport class Nothing extends Idea {\n  constructor() {\n    super()\n    this.complete = true\n  }\n\n  View(): string {\n    return \"()\"\n  }\n\n  Color(): string {\n    return \"#7dc4e4\" // Brighter blue like lists\n  }\n}\n\n// Closure idea - closing parenthesis marker (never inserted in AST)\nexport class Closure extends Idea {\n  constructor() {\n    super()\n  }\n\n  View(): string {\n    throw new Error(\"Closure should never appear in AST\")\n  }\n\n  Color(): string {\n    return \"#ff00ff\" // Brighter blue like lists\n  }\n}\n\n// Add idea - addition operator\nexport class Add extends Idea {\n  left: Idea | null = null\n  right: Idea | null = null\n\n  constructor() {\n    super()\n    this.precedence = 10\n  }\n\n  consumePre(prev: Idea): Idea | null {\n    if (prev instanceof Num) {\n      this.left = prev\n      return this\n    }\n    return null\n  }\n\n  consumePost(next: Idea): boolean {\n    if (next instanceof Num) {\n      this.right = next\n      // Only complete when both left and right are filled\n      if (this.left !== null) {\n        this.complete = true\n      }\n      return true\n    }\n    return false\n  }\n\n  View(): string {\n    const leftArg = this.left === null ? \"_\" : this.left.View()\n    const rightArg = this.right === null ? \"_\" : this.right.View()\n    return leftArg + \"+\" + rightArg\n  }\n\n  Color(): string {\n    return \"#c680f6\" // Purple for operators\n  }\n}\n", "// Console - Canvas-based 80x24 character grid for Barry playground\n// Line 1-22: Source section\n// Line 23: Status line\n// Line 24: Command line\n\nimport { Parser, LineView, Idea } from \"./barry.js\"\n\nexport interface TokenInfo {\n  endIndex: number // End position in text\n  idea: Idea // The idea parsed from this text segment\n}\n\nexport class Console {\n  private cols = 80\n  private rows = 24\n  private fontSize: number\n  private fontFamily = \"JetBrains Mono\"\n\n  // Measured character metrics\n  private charWidth: number = 0\n  private charHeight: number = 0\n\n  // Canvas\n  private canvas: HTMLCanvasElement\n  private ctx: CanvasRenderingContext2D\n\n  // Colors\n  private bgColor = \"#24273a\" // Background\n  private fgColor = \"#cad3f5\" // Default text\n  private statusBg = \"#1e2030\" // Status line background\n\n  // Parser\n  private parser = new Parser()\n\n  // Command line input state\n  private prompt = \"(_*_) \"\n  private currentLine: string = \"\"\n  private cursorPosition: number = 0\n  private history: string[] = []\n  private historyIndex: number = -1\n\n  constructor(canvasId: string, fontSize: number) {\n    this.fontSize = fontSize\n\n    // Get canvas element\n    const canvas = document.getElementById(canvasId)\n    if (!canvas || !(canvas instanceof HTMLCanvasElement)) {\n      throw new Error(`Canvas element \"${canvasId}\" not found`)\n    }\n    this.canvas = canvas\n\n    // Get 2D context\n    const ctx = this.canvas.getContext(\"2d\", { alpha: false })\n    if (!ctx) {\n      throw new Error(\"Failed to get 2D context\")\n    }\n    this.ctx = ctx\n\n    this.initialize()\n    this.setupKeyboardListeners()\n    this.redrawCommandLine()\n  }\n\n  private initialize(): void {\n    // Set font and measure character dimensions\n    this.ctx.font = `${this.fontSize}px ${this.fontFamily}`\n    const metrics = this.ctx.measureText(\"M\")\n    this.charWidth = metrics.width\n    // Line height is typically 1.5x font size for monospace\n    this.charHeight = Math.ceil(this.fontSize * 1.5)\n\n    // Size canvas to fit exactly 80x24 characters\n    this.canvas.width = this.cols * this.charWidth\n    this.canvas.height = this.rows * this.charHeight\n\n    // Configure rendering context\n    this.ctx.font = `${this.fontSize}px ${this.fontFamily}`\n    this.ctx.textBaseline = \"middle\"\n    this.ctx.textAlign = \"left\"\n\n    // Initial clear\n    this.clear()\n  }\n\n  // Clear entire console\n  clear(): void {\n    this.ctx.fillStyle = this.bgColor\n    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height)\n  }\n\n  // Clear source section (lines 1-22)\n  clearSource(): void {\n    this.ctx.fillStyle = this.bgColor\n    const y = 0\n    const height = 22 * this.charHeight\n    this.ctx.fillRect(0, y, this.canvas.width, height)\n  }\n\n  // Clear status line (line 23)\n  clearStatus(): void {\n    this.ctx.fillStyle = this.statusBg\n    const y = 22 * this.charHeight\n    const height = this.charHeight\n    this.ctx.fillRect(0, y, this.canvas.width, height)\n  }\n\n  // Clear command line (line 24)\n  clearCommand(): void {\n    this.ctx.fillStyle = this.bgColor\n    const y = 23 * this.charHeight\n    const height = this.charHeight\n    this.ctx.fillRect(0, y, this.canvas.width, height)\n  }\n\n  // Draw text starting at console coordinates (col: 0-79, row: 1-24)\n  drawText(text: string, col: number, row: number, color: string): void {\n    if (row < 1 || row > this.rows || col < 0 || col >= this.cols) {\n      return // Out of bounds\n    }\n\n    const x = col * this.charWidth\n    const y = (row - 1) * this.charHeight + this.charHeight / 2 // Middle of cell\n\n    this.ctx.fillStyle = color\n    this.ctx.fillText(text, x, y)\n  }\n\n  // Draw status line text (always on line 23)\n  drawStatus(text: string): void {\n    this.clearStatus()\n    this.drawText(text, 0, 23, this.fgColor)\n  }\n\n  // Draw command line with token-based coloring\n  drawCommandLine(text: string, tokens: TokenInfo[], cursorPos: number): void {\n    this.clearCommand()\n\n    // Draw text with token colors\n    let startIdx = 0\n    for (const token of tokens) {\n      const tokenText = text.slice(startIdx, token.endIndex)\n      const color = token.idea.Color()\n      this.drawText(tokenText, startIdx, 24, color)\n      startIdx = token.endIndex\n    }\n\n    // Draw any remaining text (unparsed) in gray\n    if (startIdx < text.length) {\n      this.drawText(text.slice(startIdx), startIdx, 24, \"#6c7086\")\n    }\n\n    // Draw cursor\n    this.drawCursor(cursorPos, 24)\n  }\n\n  // Draw cursor at position\n  private drawCursor(col: number, row: number): void {\n    if (row < 1 || row > this.rows || col < 0 || col >= this.cols) {\n      return\n    }\n\n    const x = col * this.charWidth\n    const y = row * this.charHeight - 2 // Bottom of cell\n\n    this.ctx.fillStyle = this.fgColor\n    this.ctx.fillRect(x, y, this.charWidth, 2)\n  }\n\n  // Get character dimensions (for DrawContext)\n  getCharWidth(): number {\n    return this.charWidth\n  }\n\n  getCharHeight(): number {\n    return this.charHeight\n  }\n\n  // Get canvas dimensions\n  getCols(): number {\n    return this.cols\n  }\n\n  getRows(): number {\n    return this.rows\n  }\n\n  // === Input handling ===\n\n  private setupKeyboardListeners(): void {\n    document.addEventListener(\"keydown\", (e) => {\n      this.handleKeyDown(e)\n    })\n  }\n\n  private handleKeyDown(e: KeyboardEvent): void {\n    // Prevent default browser behavior for keys we handle\n    const handledKeys = [\n      \"Enter\",\n      \"Backspace\",\n      \"ArrowLeft\",\n      \"ArrowRight\",\n      \"ArrowUp\",\n      \"ArrowDown\",\n      \"Home\",\n      \"End\",\n      \"Delete\",\n      \" \",\n    ]\n    if (handledKeys.includes(e.key)) {\n      e.preventDefault()\n    }\n\n    switch (e.key) {\n      case \"Enter\":\n        this.handleSubmit()\n        break\n      case \"Backspace\":\n        this.handleBackspace()\n        break\n      case \"Delete\":\n        this.handleDelete()\n        break\n      case \"ArrowLeft\":\n        this.handleArrowLeft()\n        break\n      case \"ArrowRight\":\n        this.handleArrowRight()\n        break\n      case \"ArrowUp\":\n        this.handleArrowUp()\n        break\n      case \"ArrowDown\":\n        this.handleArrowDown()\n        break\n      case \"Home\":\n        this.handleHome()\n        break\n      case \"End\":\n        this.handleEnd()\n        break\n      default:\n        // Handle printable characters\n        if (e.key.length === 1 && !e.ctrlKey && !e.metaKey && !e.altKey) {\n          this.handleCharacterInput(e.key)\n        }\n        break\n    }\n  }\n\n  private handleCharacterInput(char: string): void {\n    this.currentLine =\n      this.currentLine.slice(0, this.cursorPosition) +\n      char +\n      this.currentLine.slice(this.cursorPosition)\n    this.cursorPosition++\n    this.redrawCommandLine()\n  }\n\n  private handleBackspace(): void {\n    if (this.cursorPosition > 0) {\n      this.currentLine =\n        this.currentLine.slice(0, this.cursorPosition - 1) +\n        this.currentLine.slice(this.cursorPosition)\n      this.cursorPosition--\n      this.redrawCommandLine()\n    }\n  }\n\n  private handleDelete(): void {\n    if (this.cursorPosition < this.currentLine.length) {\n      this.currentLine =\n        this.currentLine.slice(0, this.cursorPosition) +\n        this.currentLine.slice(this.cursorPosition + 1)\n      this.redrawCommandLine()\n    }\n  }\n\n  private handleArrowLeft(): void {\n    if (this.cursorPosition > 0) {\n      this.cursorPosition--\n      this.redrawCommandLine()\n    }\n  }\n\n  private handleArrowRight(): void {\n    if (this.cursorPosition < this.currentLine.length) {\n      this.cursorPosition++\n      this.redrawCommandLine()\n    }\n  }\n\n  private handleArrowUp(): void {\n    if (this.history.length === 0) return\n\n    if (this.historyIndex === -1) {\n      this.historyIndex = this.history.length - 1\n    } else if (this.historyIndex > 0) {\n      this.historyIndex--\n    }\n\n    this.currentLine = this.history[this.historyIndex]\n    this.cursorPosition = this.currentLine.length\n    this.redrawCommandLine()\n  }\n\n  private handleArrowDown(): void {\n    if (this.historyIndex === -1) return\n\n    if (this.historyIndex < this.history.length - 1) {\n      this.historyIndex++\n      this.currentLine = this.history[this.historyIndex]\n    } else {\n      this.historyIndex = -1\n      this.currentLine = \"\"\n    }\n\n    this.cursorPosition = this.currentLine.length\n    this.redrawCommandLine()\n  }\n\n  private handleHome(): void {\n    this.cursorPosition = 0\n    this.redrawCommandLine()\n  }\n\n  private handleEnd(): void {\n    this.cursorPosition = this.currentLine.length\n    this.redrawCommandLine()\n  }\n\n  private handleSubmit(): void {\n    const line = this.currentLine\n\n    // Add to history if non-empty\n    if (line.trim().length > 0) {\n      this.history.push(line)\n      this.historyIndex = -1\n    }\n\n    // Parse and display result\n    if (line.trim()) {\n      try {\n        const result = this.parser.start(line)\n        const output = LineView(result)\n        this.drawStatus(output)\n      } catch (error) {\n        this.drawStatus(\"Error: \" + (error as Error).message)\n      }\n    }\n\n    // Reset input state\n    this.currentLine = \"\"\n    this.cursorPosition = 0\n    this.redrawCommandLine()\n  }\n\n  private redrawCommandLine(): void {\n    // Parse the current line to get token coloring\n    this.parser.start(this.currentLine)\n    const tokens = this.parser.tokens\n\n    // Debug: dump tokens to console\n    console.log(\"Tokens for:\", this.currentLine)\n    tokens.forEach((t, i) => {\n      console.log(\n        `  [${i}] endIndex: ${t.endIndex}, idea: ${t.idea.constructor.name}, text: \"${this.currentLine.slice(i === 0 ? 0 : tokens[i - 1].endIndex, t.endIndex)}\"`\n      )\n    })\n\n    // Build full command line text with prompt\n    const fullText = this.prompt + this.currentLine\n    const cursorCol = this.prompt.length + this.cursorPosition\n\n    // Adjust token endIndex to account for prompt\n    const adjustedTokens = tokens.map(t => ({\n      endIndex: t.endIndex + this.prompt.length,\n      idea: t.idea\n    }))\n\n    this.drawCommandLine(fullText, adjustedTokens, cursorCol)\n  }\n}\n", "// Barry Playground - Main entry point (v0.1.0)\nimport { Console } from \"./console.js\"\n\n// Wait for JetBrains Mono font to load before initializing\nasync function initPlayground() {\n  try {\n    // Wait for JetBrains Mono font to be loaded\n    await document.fonts.load('14px \"JetBrains Mono\"')\n    console.log(\"JetBrains Mono font loaded\")\n  } catch (error) {\n    console.error(\"Failed to load font:\", error)\n  }\n\n  // Initialize console (80x24) - handles everything internally\n  const con = new Console(\"console-canvas\", 14)\n\n  // Initial status message\n  con.drawStatus(\"Barry v0.1.0 - Ready\")\n}\n\n// Start when DOM is ready\nif (document.readyState === \"loading\") {\n  document.addEventListener(\"DOMContentLoaded\", initPlayground)\n} else {\n  initPlayground()\n}\n"],
  "mappings": "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",
  "names": ["nextIdea"]
}
