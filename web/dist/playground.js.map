{
  "version": 3,
  "sources": ["../src/console.ts", "../src/input.ts", "../src/barry.ts", "../src/playground.ts"],
  "sourcesContent": ["// Console - Canvas-based 80x24 character grid for Barry playground\n// Line 1-22: Source section\n// Line 23: Status line\n// Line 24: Command line\n\nexport interface TokenInfo {\n  endIndex: number // End position in text\n  kind: string // Token type (for coloring)\n  color: string // Display color\n  error?: string // Optional error message\n}\n\nexport class Console {\n  private cols = 80\n  private rows = 24\n  private fontSize: number\n  private fontFamily = \"JetBrains Mono\"\n\n  // Measured character metrics\n  private charWidth: number = 0\n  private charHeight: number = 0\n\n  // Canvas\n  private canvas: HTMLCanvasElement\n  private ctx: CanvasRenderingContext2D\n\n  // Colors\n  private bgColor = \"#24273a\" // Background\n  private fgColor = \"#cad3f5\" // Default text\n  private statusBg = \"#1e2030\" // Status line background\n\n  constructor(canvasId: string, fontSize: number = 14) {\n    this.fontSize = fontSize\n\n    // Get canvas element\n    const canvas = document.getElementById(canvasId)\n    if (!canvas || !(canvas instanceof HTMLCanvasElement)) {\n      throw new Error(`Canvas element \"${canvasId}\" not found`)\n    }\n    this.canvas = canvas\n\n    // Get 2D context\n    const ctx = this.canvas.getContext(\"2d\", { alpha: false })\n    if (!ctx) {\n      throw new Error(\"Failed to get 2D context\")\n    }\n    this.ctx = ctx\n\n    this.initialize()\n  }\n\n  private initialize(): void {\n    // Set font and measure character dimensions\n    this.ctx.font = `${this.fontSize}px ${this.fontFamily}`\n    const metrics = this.ctx.measureText(\"M\")\n    this.charWidth = metrics.width\n    // Line height is typically 1.5x font size for monospace\n    this.charHeight = Math.ceil(this.fontSize * 1.5)\n\n    // Size canvas to fit exactly 80x24 characters\n    this.canvas.width = this.cols * this.charWidth\n    this.canvas.height = this.rows * this.charHeight\n\n    // Configure rendering context\n    this.ctx.font = `${this.fontSize}px ${this.fontFamily}`\n    this.ctx.textBaseline = \"middle\"\n    this.ctx.textAlign = \"left\"\n\n    // Initial clear\n    this.clear()\n  }\n\n  // Clear entire console\n  clear(): void {\n    this.ctx.fillStyle = this.bgColor\n    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height)\n  }\n\n  // Clear source section (lines 1-22)\n  clearSource(): void {\n    this.ctx.fillStyle = this.bgColor\n    const y = 0\n    const height = 22 * this.charHeight\n    this.ctx.fillRect(0, y, this.canvas.width, height)\n  }\n\n  // Clear status line (line 23)\n  clearStatus(): void {\n    this.ctx.fillStyle = this.statusBg\n    const y = 22 * this.charHeight\n    const height = this.charHeight\n    this.ctx.fillRect(0, y, this.canvas.width, height)\n  }\n\n  // Clear command line (line 24)\n  clearCommand(): void {\n    this.ctx.fillStyle = this.bgColor\n    const y = 23 * this.charHeight\n    const height = this.charHeight\n    this.ctx.fillRect(0, y, this.canvas.width, height)\n  }\n\n  // Draw text starting at console coordinates (col: 0-79, row: 1-24)\n  drawText(text: string, col: number, row: number, color: string): void {\n    if (row < 1 || row > this.rows || col < 0 || col >= this.cols) {\n      return // Out of bounds\n    }\n\n    const x = col * this.charWidth\n    const y = (row - 1) * this.charHeight + this.charHeight / 2 // Middle of cell\n\n    this.ctx.fillStyle = color\n    this.ctx.fillText(text, x, y)\n  }\n\n  // Draw status line text (always on line 23)\n  drawStatus(text: string): void {\n    this.clearStatus()\n    this.drawText(text, 0, 23, this.fgColor)\n  }\n\n  // Draw command line with token-based coloring\n  drawCommandLine(text: string, tokens: TokenInfo[], cursorPos: number): void {\n    this.clearCommand()\n\n    // Draw text with token colors\n    let startIdx = 0\n    for (const token of tokens) {\n      const tokenText = text.slice(startIdx, token.endIndex)\n      this.drawText(tokenText, startIdx, 24, token.color)\n      startIdx = token.endIndex\n    }\n\n    // Draw any remaining text\n    if (startIdx < text.length) {\n      this.drawText(text.slice(startIdx), startIdx, 24, this.fgColor)\n    }\n\n    // Draw cursor\n    this.drawCursor(cursorPos, 24)\n  }\n\n  // Draw cursor at position\n  private drawCursor(col: number, row: number): void {\n    if (row < 1 || row > this.rows || col < 0 || col >= this.cols) {\n      return\n    }\n\n    const x = col * this.charWidth\n    const y = row * this.charHeight - 2 // Bottom of cell\n\n    this.ctx.fillStyle = this.fgColor\n    this.ctx.fillRect(x, y, this.charWidth, 2)\n  }\n\n  // Get character dimensions (for DrawContext)\n  getCharWidth(): number {\n    return this.charWidth\n  }\n\n  getCharHeight(): number {\n    return this.charHeight\n  }\n\n  // Get canvas dimensions\n  getCols(): number {\n    return this.cols\n  }\n\n  getRows(): number {\n    return this.rows\n  }\n}\n", "// Input handler for console - manages command line input\nimport { Console, TokenInfo } from \"./console.js\"\n\ninterface InputConfig {\n  onSubmit: (line: string) => void\n}\n\nexport class InputHandler {\n  private console: Console\n  private config: InputConfig\n  private prompt = \"(_*_) \"\n  private currentLine: string = \"\"\n  private cursorPosition: number = 0\n  private history: string[] = []\n  private historyIndex: number = -1\n\n  constructor(console: Console, config: InputConfig) {\n    this.console = console\n    this.config = config\n    this.setupKeyboardListeners()\n    this.redraw()\n  }\n\n  private setupKeyboardListeners(): void {\n    document.addEventListener(\"keydown\", (e) => {\n      this.handleKeyDown(e)\n    })\n  }\n\n  private handleKeyDown(e: KeyboardEvent): void {\n    // Prevent default browser behavior for keys we handle\n    const handledKeys = [\n      \"Enter\",\n      \"Backspace\",\n      \"ArrowLeft\",\n      \"ArrowRight\",\n      \"ArrowUp\",\n      \"ArrowDown\",\n      \"Home\",\n      \"End\",\n      \"Delete\",\n      \" \",\n    ]\n    if (handledKeys.includes(e.key)) {\n      e.preventDefault()\n    }\n\n    switch (e.key) {\n      case \"Enter\":\n        this.handleSubmit()\n        break\n      case \"Backspace\":\n        this.handleBackspace()\n        break\n      case \"Delete\":\n        this.handleDelete()\n        break\n      case \"ArrowLeft\":\n        this.handleArrowLeft()\n        break\n      case \"ArrowRight\":\n        this.handleArrowRight()\n        break\n      case \"ArrowUp\":\n        this.handleArrowUp()\n        break\n      case \"ArrowDown\":\n        this.handleArrowDown()\n        break\n      case \"Home\":\n        this.handleHome()\n        break\n      case \"End\":\n        this.handleEnd()\n        break\n      default:\n        // Handle printable characters\n        if (e.key.length === 1 && !e.ctrlKey && !e.metaKey && !e.altKey) {\n          this.handleCharacterInput(e.key)\n        }\n        break\n    }\n  }\n\n  private handleCharacterInput(char: string): void {\n    // Insert character at cursor position\n    this.currentLine =\n      this.currentLine.slice(0, this.cursorPosition) +\n      char +\n      this.currentLine.slice(this.cursorPosition)\n    this.cursorPosition++\n    this.redraw()\n  }\n\n  private handleBackspace(): void {\n    if (this.cursorPosition > 0) {\n      this.currentLine =\n        this.currentLine.slice(0, this.cursorPosition - 1) +\n        this.currentLine.slice(this.cursorPosition)\n      this.cursorPosition--\n      this.redraw()\n    }\n  }\n\n  private handleDelete(): void {\n    if (this.cursorPosition < this.currentLine.length) {\n      this.currentLine =\n        this.currentLine.slice(0, this.cursorPosition) +\n        this.currentLine.slice(this.cursorPosition + 1)\n      this.redraw()\n    }\n  }\n\n  private handleArrowLeft(): void {\n    if (this.cursorPosition > 0) {\n      this.cursorPosition--\n      this.redraw()\n    }\n  }\n\n  private handleArrowRight(): void {\n    if (this.cursorPosition < this.currentLine.length) {\n      this.cursorPosition++\n      this.redraw()\n    }\n  }\n\n  private handleArrowUp(): void {\n    if (this.history.length === 0) return\n\n    if (this.historyIndex === -1) {\n      this.historyIndex = this.history.length - 1\n    } else if (this.historyIndex > 0) {\n      this.historyIndex--\n    }\n\n    this.currentLine = this.history[this.historyIndex]\n    this.cursorPosition = this.currentLine.length\n    this.redraw()\n  }\n\n  private handleArrowDown(): void {\n    if (this.historyIndex === -1) return\n\n    if (this.historyIndex < this.history.length - 1) {\n      this.historyIndex++\n      this.currentLine = this.history[this.historyIndex]\n    } else {\n      this.historyIndex = -1\n      this.currentLine = \"\"\n    }\n\n    this.cursorPosition = this.currentLine.length\n    this.redraw()\n  }\n\n  private handleHome(): void {\n    this.cursorPosition = 0\n    this.redraw()\n  }\n\n  private handleEnd(): void {\n    this.cursorPosition = this.currentLine.length\n    this.redraw()\n  }\n\n  private handleSubmit(): void {\n    const line = this.currentLine\n\n    // Add to history if non-empty\n    if (line.trim().length > 0) {\n      this.history.push(line)\n      this.historyIndex = -1\n    }\n\n    // Call the submit callback\n    this.config.onSubmit(line)\n\n    // Reset input state\n    this.currentLine = \"\"\n    this.cursorPosition = 0\n    this.redraw()\n  }\n\n  private redraw(): void {\n    // For now, no token coloring - just display text\n    // TODO: Parse and generate tokens for syntax highlighting\n    const tokens: TokenInfo[] = []\n\n    // Build full command line text with prompt\n    const fullText = this.prompt + this.currentLine\n    const cursorCol = this.prompt.length + this.cursorPosition\n\n    this.console.drawCommandLine(fullText, tokens, cursorCol)\n  }\n\n  // Update display after external changes (e.g., parser feedback)\n  updateDisplay(tokens: TokenInfo[]): void {\n    const fullText = this.prompt + this.currentLine\n    const cursorCol = this.prompt.length + this.cursorPosition\n    this.console.drawCommandLine(fullText, tokens, cursorCol)\n  }\n\n  // Get current input text (for external parsing)\n  getCurrentLine(): string {\n    return this.currentLine\n  }\n}\n", "// barry.ts\n// A simple parser for parsing expressions into an AST of ideas\n\n// Combined regex pattern for token matching with global flag\n// Order matters: quoted strings, then numbers, then seals, then unquoted strings, then whitespace\nconst TOKEN_PATTERN =\n  /(?:\"(?<quoted>[^\"]*)\"|(?<number>-?\\d+\\.?\\d*)|(?<seal>[^\\w\\s\"]+)|(?<string>\\S+)|(?<append>\\s+))/g\n\n// Main parse function - converts string to Idea tree\nexport function Parse(input: string): Idea {\n  const parser = new Parser(input)\n  return parser.start()\n}\n\n// Helper function to display an idea - Lists without parentheses\nexport function LineView(idea: Idea): string {\n  if (idea instanceof List) {\n    return idea.LineView()\n  }\n  return idea.View()\n}\n\n// Test function\nexport function Test() {\n  console.log(\"=== Barry Parser Tests ===\")\n\n  const testCases = [\n    \"1234\",\n    \"  42.5  \",\n    \"-7\",\n    \"12 34\",\n    \"12 (34 56) 78\",\n    \"12+34\",\n    \"1+2+3\",\n  ]\n\n  for (const input of testCases) {\n    console.log(`\\nInput: \"${input}\"`)\n    try {\n      const result = Parse(input)\n      console.log(`  Result: ${LineView(result)}`)\n    } catch (e) {\n      console.error(`  Error: ${e}`)\n    }\n  }\n\n  console.log(\"\\n=== Tests Complete ===\")\n}\n\n// Seal map - maps seal strings to their idea constructors\nconst SealMap = new Map<string, () => Idea>([\n  [\"(\", () => new List()],\n  [\")\", () => new Closure()],\n  [\"+\", () => new Add()],\n])\n\n// Name map - maps unquoted strings to their idea constructors\nconst NameMap = new Map<string, () => Idea>([])\n\n// Parser extracts tokens on-demand and creates ideas from input string\nclass Parser {\n  private regex: RegExp\n\n  constructor(private input: string) {\n    this.regex = new RegExp(TOKEN_PATTERN.source, TOKEN_PATTERN.flags)\n  }\n\n  // Parse a seal string and return the longest matching seal idea\n  // Resets regex index so remaining characters will be matched in next call\n  private parseSeal(sealString: string, matchEndPos: number): Idea {\n    // Try matching from longest to shortest\n    for (let len = sealString.length; len > 0; len--) {\n      const candidate = sealString.substring(0, len)\n      if (SealMap.has(candidate)) {\n        // Found a match, reset index to position after this seal\n        const consumedLength = len\n        this.regex.lastIndex = matchEndPos - sealString.length + consumedLength\n        return SealMap.get(candidate)!()\n      }\n    }\n\n    // No match found - syntax error\n    throw new Error(`Unknown seal: ${sealString[0]}`)\n  }\n\n  // Entry point for parsing - handles root list with special processing\n  start(): Idea {\n    // Create root list\n    const rootList = new List()\n\n    // Append loop: consume ideas until EOF\n    while (true) {\n      const idea = this.next(null, 0)\n      if (idea === null) {\n        break\n      }\n      rootList.append(idea)\n    }\n\n    // Post-processing: convert based on number of items\n    if (rootList.items.length === 0) {\n      // Empty list becomes Nothing\n      return new Nothing()\n    } else if (rootList.items.length === 1) {\n      // Single element: (x) = x\n      return rootList.items[0]\n    }\n    // Multiple elements: return the list\n    return rootList\n  }\n\n  // Get next idea from current position\n  // prev is the idea to the left (can be null)\n  // suitor is the precedence of the left suitor (0 = no suitor, e.g. in append loops)\n  // Returns null if EOF or no valid idea can be created\n  // In look-ahead mode (prev !== null), returns null if idea doesn't need prev as left argument\n  // Rewinds position if returning null\n  next(prev: Idea | null, suitor: number): Idea | null {\n    const savedPos = this.regex.lastIndex\n    const rewind = () => {\n      this.regex.lastIndex = savedPos\n    }\n\n    let match = this.regex.exec(this.input)\n\n    while (match && match.groups?.append !== undefined) {\n      match = this.regex.exec(this.input)\n    }\n\n    if (!match || !match.groups) {\n      rewind()\n      return null\n    }\n\n    let idea: Idea | null = null\n\n    if (match.groups.number !== undefined) {\n      idea = new Num(match.groups.number)\n    } else if (match.groups.quoted !== undefined) {\n      // Create Str idea from quoted string (quotes already removed by regex)\n      idea = new Str(match.groups.quoted)\n    } else if (match.groups.string !== undefined) {\n      // Look up in NameMap, create Str if not found\n      if (NameMap.has(match.groups.string)) {\n        idea = NameMap.get(match.groups.string)!()\n      } else {\n        idea = new Str(match.groups.string)\n      }\n    } else if (match.groups.seal !== undefined) {\n      // Parse seal - may reset index for remaining characters\n      idea = this.parseSeal(match.groups.seal, this.regex.lastIndex)\n    } else {\n      rewind()\n      return null\n    }\n\n    console.log(\"Created idea:\", idea instanceof Closure ? \")\" : idea.View())\n\n    // Look-ahead check: if prev is provided, try to consume it\n    if (prev !== null) {\n      // Check precedence: only consume if our precedence is >= suitor\n      if (idea.precedence < suitor) {\n        rewind()\n        return null\n      }\n      const consumed = idea.consumePre(prev)\n      if (consumed === null) {\n        // prev not consumed, return null\n        rewind()\n        return null\n      }\n      // prev consumed, use the returned idea\n      idea = consumed\n    }\n\n    // Handle Closure - return immediately after look-ahead check\n    if (idea instanceof Closure) {\n      return idea\n    }\n\n    // Handle List - run append loop until Closure or EOF\n    if (idea instanceof List) {\n      while (true) {\n        const item = this.next(null, 0)\n        if (item === null) {\n          // EOF - end of list\n          break\n        }\n        if (item instanceof Closure) {\n          // Closure already consumed by next(), exit loop\n          break\n        }\n        idea.append(item)\n      }\n\n      // Post-process: empty list becomes Nothing\n      if (idea.items.length === 0) {\n        idea = new Nothing()\n      }\n    }\n\n    // Fill recursion: if idea has right argument slots, try to fill them\n    if (\"consumePost\" in idea) {\n      const postPos = this.regex.lastIndex\n      const rewindPost = () => {\n        this.regex.lastIndex = postPos\n      }\n      const nextIdea = this.next(null, idea.precedence)\n      if (nextIdea !== null) {\n        if (!(idea as any).consumePost(nextIdea)) {\n          // Didn't consume, rewind so next idea can be used elsewhere\n          rewindPost()\n        }\n      }\n    }\n\n    // Look-ahead recursion: check if something needs this idea as left argument\n    // Pass the suitor precedence we received, not our own\n    const nextIdea = this.next(idea, suitor)\n    if (nextIdea !== null) {\n      return nextIdea\n    }\n\n    return idea\n  }\n}\n\n// Base class for all ideas (AST nodes)\nexport abstract class Idea {\n  precedence: number = 0\n  finished: boolean = false\n  complete: boolean = false // Ideas are incomplete by default\n\n  // Default: ideas don't consume pre (return null)\n  consumePre(prev: Idea): Idea | null {\n    return null\n  }\n\n  abstract View(): string\n}\n\n// Num idea - stores numeric values\nexport class Num extends Idea {\n  value: number\n\n  constructor(match: string) {\n    super()\n    this.value = parseFloat(match)\n    this.complete = true\n  }\n\n  View(): string {\n    return this.value.toString()\n  }\n}\n\n// Str idea - stores string values\nexport class Str extends Idea {\n  value: string\n\n  constructor(match: string) {\n    super()\n    this.value = match\n    this.complete = true\n  }\n\n  View(): string {\n    return '\"' + this.value + '\"'\n  }\n}\n\n// List idea - contains sequence of ideas\nexport class List extends Idea {\n  items: Idea[] = []\n\n  constructor() {\n    super()\n    this.complete = true\n  }\n\n  append(idea: Idea) {\n    this.items.push(idea)\n  }\n\n  View(): string {\n    return \"(\" + this.items.map((item) => item.View()).join(\" \") + \")\"\n  }\n\n  LineView(): string {\n    return this.items.map((item) => item.View()).join(\" \")\n  }\n}\n\n// Nothing idea - empty expression\nexport class Nothing extends Idea {\n  constructor() {\n    super()\n    this.complete = true\n  }\n\n  View(): string {\n    return \"()\"\n  }\n}\n\n// Closure idea - closing parenthesis marker (never inserted in AST)\nexport class Closure extends Idea {\n  constructor() {\n    super()\n  }\n\n  View(): string {\n    throw new Error(\"Closure should never appear in AST\")\n  }\n}\n\n// Add idea - addition operator\nexport class Add extends Idea {\n  left: Idea | null = null\n  right: Idea | null = null\n\n  constructor() {\n    super()\n    this.precedence = 10\n  }\n\n  consumePre(prev: Idea): Idea | null {\n    if (prev instanceof Num) {\n      this.left = prev\n      return this\n    }\n    return null\n  }\n\n  consumePost(next: Idea): boolean {\n    if (next instanceof Num) {\n      this.right = next\n      // Only complete when both left and right are filled\n      if (this.left !== null) {\n        this.complete = true\n      }\n      return true\n    }\n    return false\n  }\n\n  View(): string {\n    const leftArg = this.left === null ? \"_\" : this.left.View()\n    const rightArg = this.right === null ? \"_\" : this.right.View()\n    return leftArg + \"+\" + rightArg\n  }\n}\n", "// Barry Playground - Main entry point (v0.1.0)\nimport { Console } from \"./console.js\"\nimport { InputHandler } from \"./input.js\"\nimport { Parse, LineView } from \"./barry.js\"\n\nfunction handleInput(line: string, con: Console): void {\n  if (!line.trim()) {\n    return\n  }\n\n  try {\n    // Parse the input\n    const result = Parse(line)\n\n    // For now, just show result in status line\n    const output = LineView(result)\n    con.drawStatus(output)\n  } catch (error) {\n    // Display error in status line\n    con.drawStatus(\"Error: \" + (error as Error).message)\n  }\n}\n\n// Wait for JetBrains Mono font to load before initializing\nasync function initPlayground() {\n  try {\n    // Load JetBrains Mono font\n    await document.fonts.load('14px \"JetBrains Mono\"')\n    console.log(\"JetBrains Mono font loaded\")\n  } catch (error) {\n    console.error(\"Failed to load font:\", error)\n  }\n\n  // Initialize console (80x24)\n  const con = new Console(\"terminal-canvas\", 14)\n\n  // Initialize input handler\n  const input = new InputHandler(con, {\n    onSubmit: (line: string) => {\n      handleInput(line, con)\n    },\n  })\n\n  // Initial status message\n  con.drawStatus(\"Barry v0.1.0 - Ready\")\n}\n\n// Start when DOM is ready\nif (document.readyState === \"loading\") {\n  document.addEventListener(\"DOMContentLoaded\", initPlayground)\n} else {\n  initPlayground()\n}\n"],
  "mappings": "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",
  "names": ["Console", "canvasId", "fontSize", "canvas", "ctx", "metrics", "y", "height", "text", "col", "row", "color", "x", "tokens", "cursorPos", "startIdx", "token", "tokenText", "InputHandler", "console", "config", "e", "char", "line", "tokens", "fullText", "cursorCol", "TOKEN_PATTERN", "Parse", "input", "Parser", "LineView", "idea", "List", "Test", "testCases", "result", "SealMap", "Closure", "Add", "NameMap", "sealString", "matchEndPos", "len", "candidate", "consumedLength", "rootList", "Nothing", "prev", "suitor", "savedPos", "rewind", "match", "Num", "Str", "consumed", "item", "postPos", "rewindPost", "nextIdea", "Idea", "next", "leftArg", "rightArg", "handleInput", "line", "con", "result", "Parse", "output", "LineView", "error", "initPlayground", "Console", "input", "InputHandler"]
}
